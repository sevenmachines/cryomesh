.TH "cryomesh::components::Node" 3 "Tue Mar 6 2012" "cryomesh" \" -*- nroff -*-
.ad l
.nh
.SH NAME
cryomesh::components::Node \- 
.PP
\fBNode\fP is an accumulation and computational nodal point of impulses\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Node\&.h>\fP
.PP
Inherits \fBcryomesh::dataobjects::DataObjectController< unsigned long int, double >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBActivationState\fP { \fBPositive\fP, \fBNegative\fP, \fBNone\fP }"
.br
.RI "\fIEnum representing posible activation states\&. \fP"
.ti -1c
.RI "enum \fBRecoverySetting\fP { \fBCLEAR_ALL_IMPULSES\fP =  1, \fBCLEAR_ACTIVE_IMPULSES\fP =  2, \fBDEACTIVATE_DURING_RECOVERY\fP =  4 }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBNode\fP ()"
.br
.RI "\fIContructor\&. \fP"
.ti -1c
.RI "virtual \fB~Node\fP ()"
.br
.RI "\fIDestructor\&. \fP"
.ti -1c
.RI "virtual void \fBupdate\fP ()"
.br
.ti -1c
.RI "virtual void \fBforceFire\fP ()"
.br
.RI "\fIForce the node to fire\&. \fP"
.ti -1c
.RI "virtual boost::shared_ptr
.br
< \fBImpulse\fP > \fBaddImpulse\fP (boost::shared_ptr< \fBImpulse\fP > impulse)"
.br
.RI "\fIAdd incoming \fBImpulse\fP\&. \fP"
.ti -1c
.RI "virtual void \fBaddImpulses\fP (std::list< boost::shared_ptr< \fBImpulse\fP > > \fBimpulses\fP)"
.br
.RI "\fIAdd a list of incoming Impulses\&. \fP"
.ti -1c
.RI "const \fBcommon::Connector\fP< \fBNode\fP, 
.br
\fBConnection\fP > & \fBgetConnector\fP () const "
.br
.RI "\fIGet the Connector object for this \fBNode\fP\&. \fP"
.ti -1c
.RI "\fBcommon::Connector\fP< \fBNode\fP, 
.br
\fBConnection\fP > & \fBgetMutableConnector\fP ()"
.br
.RI "\fIGet the mutable Connector object for this \fBNode\fP\&. \fP"
.ti -1c
.RI "bool \fBisInputIsolated\fP () const "
.br
.ti -1c
.RI "bool \fBisOutputIsolated\fP () const "
.br
.ti -1c
.RI "void \fBconnectInput\fP (boost::shared_ptr< \fBConnection\fP > con)"
.br
.ti -1c
.RI "void \fBconnectOutput\fP (boost::shared_ptr< \fBConnection\fP > con)"
.br
.ti -1c
.RI "const \fBImpulseCollection\fP & \fBgetImpulses\fP () const "
.br
.RI "\fIGet the collection of Impulses for this \fBNode\fP\&. \fP"
.ti -1c
.RI "const boost::shared_ptr< \fBImpulse\fP > \fBgetEmittedImpulse\fP () const "
.br
.RI "\fIGet the \fBImpulse\fP that is emitted\&. \fP"
.ti -1c
.RI "boost::shared_ptr< \fBImpulse\fP > \fBgetMutableEmittedImpulse\fP ()"
.br
.RI "\fIGet the mutable \fBImpulse\fP that is emitted\&. \fP"
.ti -1c
.RI "virtual void \fBemitImpulsePositive\fP ()"
.br
.RI "\fIEmit a positive impulse to outgoing connections\&. \fP"
.ti -1c
.RI "virtual void \fBemitImpulseNegative\fP ()"
.br
.RI "\fIEmit a negative impulse to outgoing connections\&. \fP"
.ti -1c
.RI "\fBImpulseCollection\fP & \fBgetMutableImpulses\fP ()"
.br
.RI "\fIGet the mutable collection of Impulses for this \fBNode\fP\&. \fP"
.ti -1c
.RI "const std::map< \fBcommon::Cycle\fP, 
.br
double > & \fBgetActivities\fP () const "
.br
.RI "\fIGet the collection of all activities\&. \fP"
.ti -1c
.RI "double \fBupdateActivity\fP ()"
.br
.RI "\fIUpdate and get the current activity of the node\&. \fP"
.ti -1c
.RI "double \fBupdateActivity\fP (const \fBcommon::Cycle\fP &cycle)"
.br
.RI "\fIUpdate and get the activity of the node on specific cycle\&. \fP"
.ti -1c
.RI "double \fBgetActivity\fP () const "
.br
.RI "\fIGet the current activity of the node\&. \fP"
.ti -1c
.RI "double \fBgetActivity\fP (const \fBcommon::Cycle\fP &cycle) const "
.br
.RI "\fIGet the activity of the node on specific cycle\&. \fP"
.ti -1c
.RI "double \fBgetActivityThreshold\fP () const "
.br
.ti -1c
.RI "double \fBsetActivity\fP (double activity)"
.br
.RI "\fISet the current activity of the node\&. \fP"
.ti -1c
.RI "double \fBsetActivity\fP (const \fBcommon::Cycle\fP &cycle, double activity)"
.br
.RI "\fISet the activity at cycle of the node\&. \fP"
.ti -1c
.RI "boost::shared_ptr
.br
< \fBmanager::DatabaseObject\fP > \fBgetDatabaseObject\fP () const "
.br
.RI "\fIReturn a database object for this node\&. \fP"
.ti -1c
.RI "const spacial::Point & \fBgetPosition\fP () const "
.br
.RI "\fIget the position of the node \fP"
.ti -1c
.RI "void \fBsetPosition\fP (const spacial::Point &new_position)"
.br
.RI "\fISet the spacial position of the node, remembering to update connections lengths\&. \fP"
.ti -1c
.RI "\fBActivationState\fP \fBgetLastActivationState\fP () const "
.br
.RI "\fIGet the last activation state\&. \fP"
.ti -1c
.RI "void \fBrandomise\fP ()"
.br
.RI "\fIRandomise the nodes state\&. \fP"
.ti -1c
.RI "virtual void \fBenableDebug\fP (bool b)"
.br
.ti -1c
.RI "bool \fBisTriggered\fP (\fBActivationState\fP state=\fBNone\fP)"
.br
.RI "\fICheck if \fBNode\fP is currently triggered\&. \fP"
.ti -1c
.RI "bool \fBisActive\fP (const \fBActivationState\fP state=\fBNone\fP)"
.br
.RI "\fICheck if \fBNode\fP is currently activated\&. \fP"
.ti -1c
.RI "bool \fBisLive\fP ()"
.br
.RI "\fICheck if \fBNode\fP is live, ie active at any point in now or the future\&. \fP"
.ti -1c
.RI "void \fBdestroyAllConnections\fP ()"
.br
.RI "\fIDestroy all connections\&. \fP"
.ti -1c
.RI "void \fBdestroyAllInputConnections\fP ()"
.br
.RI "\fIDestroy Input connections by removing them all from both their attached input and output nodes\&. \fP"
.ti -1c
.RI "void \fBdestroyAllOutputConnections\fP ()"
.br
.RI "\fIDestroy Output connections by removing them all from both their attached input and output nodes\&. \fP"
.ti -1c
.RI "bool \fBisPrimaryInputAttachedNode\fP () const "
.br
.ti -1c
.RI "bool \fBisPrimaryOutputAttachedNode\fP () const "
.br
.ti -1c
.RI "std::vector< boost::shared_ptr
.br
< \fBConnection\fP > > \fBgetPrimaryInputConnections\fP ()"
.br
.ti -1c
.RI "std::vector< boost::shared_ptr
.br
< \fBConnection\fP > > \fBgetPrimaryOutputConnections\fP ()"
.br
.ti -1c
.RI "std::ostream & \fBprintConnections\fP (std::ostream &os, const std::map< boost::uuids::uuid, boost::shared_ptr< \fBConnection\fP > > &all_cons, const std::string formatter='') const "
.br
.ti -1c
.RI "virtual void \fBenableLogging\fP (bool enable)"
.br
.RI "\fIWhether logging is enabled or not\&. \fP"
.ti -1c
.RI "virtual const std::map
.br
< unsigned long int, double > & \fBgetMap\fP ()"
.br
.RI "\fIGet all cycle values\&. \fP"
.ti -1c
.RI "virtual const 
.br
\fBdataobjects::DataObject\fP
.br
< unsigned long int, double > & \fBgetDataObject\fP ()"
.br
.RI "\fIGet data object\&. \fP"
.ti -1c
.RI "virtual void \fBrefreshDataObject\fP ()"
.br
.RI "\fIFunction to allow refreshing implementation if required by subclasses\&. \fP"
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static boost::shared_ptr< \fBNode\fP > \fBgetRandom\fP (const spacial::Point &max_point=\fBMAX_BOUNDING_BOX_POINT\fP)"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const int \fBMAX_ACTIVITIES_LENGTH\fP = 10"
.br
.ti -1c
.RI "static const double \fBMAX_ACTIVITY_THRESHOLD\fP = 3 * \fBImpulse::MAX_ACTIVITY\fP"
.br
.ti -1c
.RI "static const double \fBMIN_ACTIVITY_THRESHOLD\fP = 1 * \fBImpulse::MAX_ACTIVITY\fP"
.br
.ti -1c
.RI "static const spacial::Point \fBMAX_BOUNDING_BOX_POINT\fP = spacial::Point(100, 100, 100)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual \fBNode::ActivationState\fP \fBcheckActivationState\fP ()"
.br
.RI "\fICheck level of impulses and decide whether to activate the node\&. \fP"
.ti -1c
.RI "virtual \fBNode::ActivationState\fP \fBcheckFire\fP ()"
.br
.RI "\fICheck if the object is ready to fire off an impulse and carry it out\&. \fP"
.ti -1c
.RI "virtual void \fBupdateImpulses\fP ()"
.br
.RI "\fIUpdate the collection of impulses by one cycle\&. \fP"
.ti -1c
.RI "virtual void \fBemitImpulse\fP (bool positive)"
.br
.RI "\fIEmit an impulse to outgoing connections\&. \fP"
.ti -1c
.RI "virtual double \fBaddActivity\fP (\fBcommon::Cycle\fP, double activity)"
.br
.RI "\fIAdd an activity to the list of activities\&. \fP"
.ti -1c
.RI "virtual void \fBupdatePosition\fP ()"
.br
.RI "\fIRecalculate state of node and connections based on current position\&. \fP"
.ti -1c
.RI "virtual void \fBenterRecovery\fP (const int recovery_settings=\fBCLEAR_ALL_IMPULSES\fP)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBdataobjects::DataObject\fP
.br
< unsigned long int, double > \fBdataObject\fP"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "double \fBactivityThreshold\fP"
.br
.ti -1c
.RI "boost::shared_ptr
.br
< \fBcommon::Connector\fP< \fBNode\fP, 
.br
\fBConnection\fP > > \fBconnector\fP"
.br
.ti -1c
.RI "\fBImpulseCollection\fP \fBimpulses\fP"
.br
.ti -1c
.RI "boost::shared_ptr< \fBImpulse\fP > \fBemittedImpulse\fP"
.br
.ti -1c
.RI "\fBdataobjects::DataObject\fP
.br
< \fBcommon::Cycle\fP, double > \fBactivities\fP"
.br
.ti -1c
.RI "spacial::Point \fBposition\fP"
.br
.ti -1c
.RI "\fBActivationState\fP \fBlastActivationState\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &os, const \fBNode\fP &obj)"
.br
.RI "\fITo stream operator\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
\fBNode\fP is an accumulation and computational nodal point of impulses\&. 

A \fBNode\fP represents the end point of one or many connections\&. Here, Impulses are accumulated and new Impulses generated depending on some determining criteria 
.PP
Definition at line 38 of file Node\&.h\&.
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBcryomesh::components::Node::ActivationState\fP"
.PP
Enum representing posible activation states\&. Last activation state\&. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIPositive \fP\fP
.TP
\fB\fINegative \fP\fP
.TP
\fB\fINone \fP\fP

.PP
Definition at line 45 of file Node\&.h\&.
.SS "enum \fBcryomesh::components::Node::RecoverySetting\fP"
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICLEAR_ALL_IMPULSES \fP\fP
.TP
\fB\fICLEAR_ACTIVE_IMPULSES \fP\fP
.TP
\fB\fIDEACTIVATE_DURING_RECOVERY \fP\fP

.PP
Definition at line 49 of file Node\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBcryomesh::components::Node::Node\fP ()"
.PP
Contructor\&. Contructor for \fBNode\fP 
.PP
Definition at line 37 of file Node\&.cpp\&.
.PP
References activities, connector, emittedImpulse, MAX_ACTIVITIES_LENGTH, and cryomesh::dataobjects::DataObject< U, T >::setDatasetMaximumSize()\&.
.SS "\fBcryomesh::components::Node::~Node\fP ()\fC [virtual]\fP"
.PP
Destructor\&. Destructor for \fBNode\fP 
.PP
Definition at line 46 of file Node\&.cpp\&.
.SH "Member Function Documentation"
.PP 
.SS "double \fBcryomesh::components::Node::addActivity\fP (\fBcommon::Cycle\fPcycle, doubleactivity)\fC [protected, virtual]\fP"
.PP
Add an activity to the list of activities\&. \fBParameters:\fP
.RS 4
\fICycle\fP cycle The cycle this activity is on 
.br
\fIdouble\fP activity The activity to add
.RE
.PP
\fBReturns:\fP
.RS 4
The current activity 
.RE
.PP

.PP
Definition at line 291 of file Node\&.cpp\&.
.PP
References activities, and cryomesh::dataobjects::DataObject< U, T >::insert()\&.
.PP
Referenced by setActivity()\&.
.SS "boost::shared_ptr< \fBImpulse\fP > \fBcryomesh::components::Node::addImpulse\fP (boost::shared_ptr< \fBImpulse\fP >impulse)\fC [virtual]\fP"
.PP
Add incoming \fBImpulse\fP\&. \fBParameters:\fP
.RS 4
\fIboost::shared_ptr<Impulse>\fP impulse The \fBImpulse\fP to add 
.RE
.PP
\fBReturns:\fP
.RS 4
boost::shared_ptr<Impulse> The impulse added, null if none added 
.RE
.PP

.PP
Definition at line 141 of file Node\&.cpp\&.
.PP
References getMutableImpulses(), and cryomesh::common::TimeKeeper::getTimeKeeper()\&.
.PP
Referenced by addImpulses(), and forceFire()\&.
.SS "void \fBcryomesh::components::Node::addImpulses\fP (std::list< boost::shared_ptr< \fBImpulse\fP > >impulses)\fC [virtual]\fP"
.PP
Add a list of incoming Impulses\&. \fBParameters:\fP
.RS 4
\fIstd::list<boost::shared_ptr<Impulse>\fP > impulses The Impulses to add 
.RE
.PP

.PP
Definition at line 151 of file Node\&.cpp\&.
.PP
References addImpulse(), getImpulses(), and impulses\&.
.SS "\fBNode::ActivationState\fP \fBcryomesh::components::Node::checkActivationState\fP ()\fC [protected, virtual]\fP"
.PP
Check level of impulses and decide whether to activate the node\&. \fBReturns:\fP
.RS 4
\fBNode::ActivationState\fP Positive if activity is over threshold, negative if under -threshold, None otherwise 
.RE
.PP

.PP
Definition at line 173 of file Node\&.cpp\&.
.PP
References getActivityThreshold(), Negative, None, Positive, and updateActivity()\&.
.PP
Referenced by checkFire()\&.
.SS "\fBNode::ActivationState\fP \fBcryomesh::components::Node::checkFire\fP ()\fC [protected, virtual]\fP"
.PP
Check if the object is ready to fire off an impulse and carry it out\&. \fBReturns:\fP
.RS 4
ActivationState Return the action that was taken 
.RE
.PP

.PP
Definition at line 92 of file Node\&.cpp\&.
.PP
References checkActivationState(), emitImpulseNegative(), emitImpulsePositive(), enterRecovery(), Negative, and Positive\&.
.PP
Referenced by update()\&.
.SS "void \fBcryomesh::components::Node::connectInput\fP (boost::shared_ptr< \fBConnection\fP >con)"
.PP
Definition at line 469 of file Node\&.cpp\&.
.PP
References getMutableConnector()\&.
.SS "void \fBcryomesh::components::Node::connectOutput\fP (boost::shared_ptr< \fBConnection\fP >con)"
.PP
Definition at line 472 of file Node\&.cpp\&.
.PP
References getMutableConnector()\&.
.SS "void \fBcryomesh::components::Node::destroyAllConnections\fP ()"
.PP
Destroy all connections\&. 
.PP
Definition at line 476 of file Node\&.cpp\&.
.PP
References destroyAllInputConnections(), and destroyAllOutputConnections()\&.
.SS "void \fBcryomesh::components::Node::destroyAllInputConnections\fP ()"
.PP
Destroy Input connections by removing them all from both their attached input and output nodes\&. 
.PP
Definition at line 481 of file Node\&.cpp\&.
.PP
References getMutableConnector()\&.
.PP
Referenced by destroyAllConnections()\&.
.SS "void \fBcryomesh::components::Node::destroyAllOutputConnections\fP ()"
.PP
Destroy Output connections by removing them all from both their attached input and output nodes\&. 
.PP
Definition at line 498 of file Node\&.cpp\&.
.PP
References getMutableConnector()\&.
.PP
Referenced by destroyAllConnections()\&.
.SS "void \fBcryomesh::components::Node::emitImpulse\fP (boolpositive)\fC [protected, virtual]\fP"
.PP
Emit an impulse to outgoing connections\&. \fBParameters:\fP
.RS 4
\fIbool\fP positive Is the impulse to be emitted positive or negative 
.RE
.PP

.PP
Definition at line 199 of file Node\&.cpp\&.
.PP
References cryomesh::components::Connection::add(), getEmittedImpulse(), cryomesh::components::Connection::getImpulses(), getMutableConnector(), and getMutableEmittedImpulse()\&.
.PP
Referenced by emitImpulseNegative(), and emitImpulsePositive()\&.
.SS "void \fBcryomesh::components::Node::emitImpulseNegative\fP ()\fC [virtual]\fP"
.PP
Emit a negative impulse to outgoing connections\&. 
.PP
Definition at line 195 of file Node\&.cpp\&.
.PP
References emitImpulse()\&.
.PP
Referenced by checkFire()\&.
.SS "void \fBcryomesh::components::Node::emitImpulsePositive\fP ()\fC [virtual]\fP"
.PP
Emit a positive impulse to outgoing connections\&. 
.PP
Definition at line 191 of file Node\&.cpp\&.
.PP
References emitImpulse()\&.
.PP
Referenced by checkFire()\&.
.SS "void \fBcryomesh::components::Node::enableDebug\fP (boolb)\fC [virtual]\fP"
.PP
Definition at line 545 of file Node\&.cpp\&.
.SS "virtual void \fBcryomesh::dataobjects::DataObjectController\fP< unsigned long int , double  >::\fBenableLogging\fP (boolenable)\fC [inline, virtual, inherited]\fP"
.PP
Whether logging is enabled or not\&. \fBParameters:\fP
.RS 4
\fIbool\fP enable True to enable logging, false otherwise 
.RE
.PP

.PP
Definition at line 47 of file DataObjectController\&.h\&.
.PP
References cryomesh::dataobjects::DataObjectController< U, T >::dataObject\&.
.SS "void \fBcryomesh::components::Node::enterRecovery\fP (const intrecovery_settings = \fC\fBCLEAR_ALL_IMPULSES\fP\fP)\fC [protected, virtual]\fP"
.PP
Definition at line 115 of file Node\&.cpp\&.
.PP
References CLEAR_ACTIVE_IMPULSES, CLEAR_ALL_IMPULSES, cryomesh::components::ImpulseCollection::clearActiveImpulses(), cryomesh::common::TimeKeeper::getTimeKeeper(), and impulses\&.
.PP
Referenced by checkFire()\&.
.SS "void \fBcryomesh::components::Node::forceFire\fP ()\fC [virtual]\fP"
.PP
Force the node to fire\&. 
.PP
Definition at line 80 of file Node\&.cpp\&.
.PP
References addImpulse(), and cryomesh::components::Impulse::getTriggerImpulse()\&.
.SS "const std::map< \fBcommon::Cycle\fP, double > & \fBcryomesh::components::Node::getActivities\fP () const"
.PP
Get the collection of all activities\&. \fBReturns:\fP
.RS 4
std::list<double> & List of activities 
.RE
.PP

.PP
Definition at line 259 of file Node\&.cpp\&.
.PP
References activities, and cryomesh::dataobjects::DataObject< U, T >::getMap()\&.
.PP
Referenced by update()\&.
.SS "double \fBcryomesh::components::Node::getActivity\fP () const"
.PP
Get the current activity of the node\&. \fBReturns:\fP
.RS 4
double The current activity 
.RE
.PP

.PP
Definition at line 263 of file Node\&.cpp\&.
.PP
References cryomesh::common::TimeKeeper::getTimeKeeper()\&.
.PP
Referenced by getDatabaseObject(), isActive(), cryomesh::structures::Mesh::update(), updateActivity(), and cryomesh::structures::Mesh::warp()\&.
.SS "double \fBcryomesh::components::Node::getActivity\fP (const \fBcommon::Cycle\fP &cycle) const"
.PP
Get the activity of the node on specific cycle\&. \fBReturns:\fP
.RS 4
double The current activity 
.RE
.PP

.PP
Definition at line 267 of file Node\&.cpp\&.
.PP
References cryomesh::components::ImpulseCollection::getActivity(), and getImpulses()\&.
.SS "double \fBcryomesh::components::Node::getActivityThreshold\fP () const"
.PP
Definition at line 271 of file Node\&.cpp\&.
.PP
References activityThreshold\&.
.PP
Referenced by checkActivationState(), and cryomesh::components::operator<<()\&.
.SS "const \fBcommon::Connector\fP< \fBNode\fP, \fBConnection\fP > & \fBcryomesh::components::Node::getConnector\fP () const"
.PP
Get the Connector object for this \fBNode\fP\&. \fBReturns:\fP
.RS 4
const common::Connector<Node, Connection> & The Connector for this object 
.RE
.PP

.PP
Definition at line 84 of file Node\&.cpp\&.
.PP
References connector\&.
.PP
Referenced by getPrimaryInputConnections(), getPrimaryOutputConnections(), isInputIsolated(), isOutputIsolated(), isPrimaryInputAttachedNode(), isPrimaryOutputAttachedNode(), and cryomesh::components::operator<<()\&.
.SS "boost::shared_ptr< \fBmanager::DatabaseObject\fP > \fBcryomesh::components::Node::getDatabaseObject\fP () const"
.PP
Return a database object for this node\&. \fBReturns:\fP
.RS 4
DatabaseObject 
.RE
.PP

.PP
Definition at line 296 of file Node\&.cpp\&.
.PP
References getActivity(), cryomesh::common::TimeKeeper::getCycle(), getPosition(), cryomesh::common::TimeKeeper::getTimeKeeper(), and cryomesh::common::Cycle::toULInt()\&.
.SS "virtual const \fBdataobjects::DataObject\fP<unsigned long int , double >& \fBcryomesh::dataobjects::DataObjectController\fP< unsigned long int , double  >::\fBgetDataObject\fP ()\fC [inline, virtual, inherited]\fP"
.PP
Get data object\&. \fBReturns:\fP
.RS 4
dataobjects::DataObject<U,T> & The data object 
.RE
.PP

.PP
Definition at line 68 of file DataObjectController\&.h\&.
.PP
References cryomesh::dataobjects::DataObjectController< U, T >::dataObject, and cryomesh::dataobjects::DataObjectController< U, T >::refreshDataObject()\&.
.SS "const boost::shared_ptr< \fBImpulse\fP > \fBcryomesh::components::Node::getEmittedImpulse\fP () const"
.PP
Get the \fBImpulse\fP that is emitted\&. \fBReturns:\fP
.RS 4
const boost::shared_ptr< Impulse > The emitted \fBImpulse\fP 
.RE
.PP

.PP
Definition at line 247 of file Node\&.cpp\&.
.PP
References emittedImpulse\&.
.PP
Referenced by emitImpulse()\&.
.SS "const \fBImpulseCollection\fP & \fBcryomesh::components::Node::getImpulses\fP () const"
.PP
Get the collection of Impulses for this \fBNode\fP\&. \fBReturns:\fP
.RS 4
const \fBImpulseCollection\fP & The collection of Impulses for this \fBNode\fP 
.RE
.PP

.PP
Definition at line 243 of file Node\&.cpp\&.
.PP
References impulses\&.
.PP
Referenced by addImpulses(), getActivity(), isLive(), cryomesh::components::operator<<(), and updateActivity()\&.
.SS "\fBNode::ActivationState\fP \fBcryomesh::components::Node::getLastActivationState\fP () const"
.PP
Get the last activation state\&. \fBReturns:\fP
.RS 4
ActivationState Return the last activation state 
.RE
.PP

.PP
Definition at line 314 of file Node\&.cpp\&.
.PP
References lastActivationState\&.
.PP
Referenced by isTriggered()\&.
.SS "virtual const std::map<unsigned long int , double >& \fBcryomesh::dataobjects::DataObjectController\fP< unsigned long int , double  >::\fBgetMap\fP ()\fC [inline, virtual, inherited]\fP"
.PP
Get all cycle values\&. \fBReturns:\fP
.RS 4
std::map<unsigned long int, double> & The cycle values 
.RE
.PP

.PP
Definition at line 57 of file DataObjectController\&.h\&.
.PP
References cryomesh::dataobjects::DataObjectController< U, T >::dataObject, and cryomesh::dataobjects::DataObjectController< U, T >::refreshDataObject()\&.
.SS "\fBcommon::Connector\fP< \fBNode\fP, \fBConnection\fP > & \fBcryomesh::components::Node::getMutableConnector\fP ()"
.PP
Get the mutable Connector object for this \fBNode\fP\&. \fBReturns:\fP
.RS 4
common::Connector<Node, Connection> & The mutable Connector for this object 
.RE
.PP

.PP
Definition at line 88 of file Node\&.cpp\&.
.PP
References connector\&.
.PP
Referenced by connectInput(), connectOutput(), destroyAllInputConnections(), destroyAllOutputConnections(), and emitImpulse()\&.
.SS "boost::shared_ptr< \fBImpulse\fP > \fBcryomesh::components::Node::getMutableEmittedImpulse\fP ()"
.PP
Get the mutable \fBImpulse\fP that is emitted\&. \fBReturns:\fP
.RS 4
boost::shared_ptr< Impulse > The mutable emitted \fBImpulse\fP 
.RE
.PP

.PP
Definition at line 251 of file Node\&.cpp\&.
.PP
References emittedImpulse\&.
.PP
Referenced by emitImpulse()\&.
.SS "\fBImpulseCollection\fP & \fBcryomesh::components::Node::getMutableImpulses\fP ()"
.PP
Get the mutable collection of Impulses for this \fBNode\fP\&. \fBReturns:\fP
.RS 4
\fBImpulseCollection\fP & The mutable collection of Impulses for this \fBNode\fP 
.RE
.PP

.PP
Definition at line 255 of file Node\&.cpp\&.
.PP
References impulses\&.
.PP
Referenced by addImpulse(), and update()\&.
.SS "const spacial::Point & \fBcryomesh::components::Node::getPosition\fP () const"
.PP
get the position of the node \fBReturns:\fP
.RS 4
spacial::Point The spacial location of the node 
.RE
.PP

.PP
Definition at line 305 of file Node\&.cpp\&.
.PP
References position\&.
.PP
Referenced by getDatabaseObject(), cryomesh::structures::Mesh::update(), and cryomesh::structures::Mesh::warp()\&.
.SS "std::vector< boost::shared_ptr< \fBConnection\fP > > \fBcryomesh::components::Node::getPrimaryInputConnections\fP ()"
.PP
Definition at line 425 of file Node\&.cpp\&.
.PP
References getConnector()\&.
.SS "std::vector< boost::shared_ptr< \fBConnection\fP > > \fBcryomesh::components::Node::getPrimaryOutputConnections\fP ()"
.PP
Definition at line 447 of file Node\&.cpp\&.
.PP
References getConnector()\&.
.SS "boost::shared_ptr< \fBNode\fP > \fBcryomesh::components::Node::getRandom\fP (const spacial::Point &max_point = \fC\fBMAX_BOUNDING_BOX_POINT\fP\fP)\fC [static]\fP"
.PP
Definition at line 26 of file Node\&.cpp\&.
.PP
Referenced by cryomesh::manipulators::ClusterArchitect::createRandomNodes(), and randomise()\&.
.SS "bool \fBcryomesh::components::Node::isActive\fP (const \fBActivationState\fPstate = \fC\fBNone\fP\fP)"
.PP
Check if \fBNode\fP is currently activated\&. \fBParameters:\fP
.RS 4
\fIActivationState\fP Positive for positive activity test, Negative for negative activity test, None for any activity test
.RE
.PP
\fBReturns:\fP
.RS 4
bool True if activated, false otherwise 
.RE
.PP

.PP
Definition at line 333 of file Node\&.cpp\&.
.PP
References getActivity(), Negative, None, and Positive\&.
.SS "bool \fBcryomesh::components::Node::isInputIsolated\fP () const"
.PP
Definition at line 361 of file Node\&.cpp\&.
.PP
References getConnector()\&.
.PP
Referenced by isPrimaryInputAttachedNode()\&.
.SS "bool \fBcryomesh::components::Node::isLive\fP ()"
.PP
Check if \fBNode\fP is live, ie active at any point in now or the future\&. \fBReturns:\fP
.RS 4
bool True if live, false otherwise 
.RE
.PP

.PP
Definition at line 352 of file Node\&.cpp\&.
.PP
References getImpulses()\&.
.SS "bool \fBcryomesh::components::Node::isOutputIsolated\fP () const"
.PP
Definition at line 368 of file Node\&.cpp\&.
.PP
References getConnector()\&.
.PP
Referenced by isPrimaryOutputAttachedNode()\&.
.SS "bool \fBcryomesh::components::Node::isPrimaryInputAttachedNode\fP () const"
.PP
Definition at line 375 of file Node\&.cpp\&.
.PP
References getConnector(), and isInputIsolated()\&.
.PP
Referenced by cryomesh::components::operator<<()\&.
.SS "bool \fBcryomesh::components::Node::isPrimaryOutputAttachedNode\fP () const"
.PP
Definition at line 400 of file Node\&.cpp\&.
.PP
References getConnector(), and isOutputIsolated()\&.
.PP
Referenced by cryomesh::components::operator<<()\&.
.SS "bool \fBcryomesh::components::Node::isTriggered\fP (\fBActivationState\fPstate = \fC\fBNone\fP\fP)"
.PP
Check if \fBNode\fP is currently triggered\&. \fBParameters:\fP
.RS 4
\fIActivationState\fP Positive for positive trigger test, Negative for negative trigger test, None for any trigger test
.RE
.PP
\fBReturns:\fP
.RS 4
bool True if triggered, false otherwise 
.RE
.PP

.PP
Definition at line 323 of file Node\&.cpp\&.
.PP
References getLastActivationState(), and None\&.
.SS "std::ostream & \fBcryomesh::components::Node::printConnections\fP (std::ostream &os, const std::map< boost::uuids::uuid, boost::shared_ptr< \fBConnection\fP > > &all_cons, const std::stringformatter = \fC''\fP) const"
.PP
Definition at line 577 of file Node\&.cpp\&.
.PP
Referenced by cryomesh::components::operator<<()\&.
.SS "void \fBcryomesh::components::Node::randomise\fP ()"
.PP
Randomise the nodes state\&. 
.PP
Definition at line 318 of file Node\&.cpp\&.
.PP
References activityThreshold, emittedImpulse, getRandom(), MAX_ACTIVITY_THRESHOLD, and MIN_ACTIVITY_THRESHOLD\&.
.SS "virtual void \fBcryomesh::dataobjects::DataObjectController\fP< unsigned long int , double  >::\fBrefreshDataObject\fP ()\fC [inline, virtual, inherited]\fP"
.PP
Function to allow refreshing implementation if required by subclasses\&. 
.PP
Reimplemented in \fBcryomesh::components::ImpulseCollection\fP\&.
.PP
Definition at line 76 of file DataObjectController\&.h\&.
.SS "double \fBcryomesh::components::Node::setActivity\fP (doubleactivity)"
.PP
Set the current activity of the node\&. \fBParameters:\fP
.RS 4
\fIdouble\fP The current activity value to be set
.RE
.PP
\fBReturns:\fP
.RS 4
double The activity set 
.RE
.PP

.PP
Definition at line 283 of file Node\&.cpp\&.
.PP
References cryomesh::common::TimeKeeper::getTimeKeeper()\&.
.PP
Referenced by updateActivity(), and cryomesh::structures::Mesh::warp()\&.
.SS "double \fBcryomesh::components::Node::setActivity\fP (const \fBcommon::Cycle\fP &cycle, doubleactivity)"
.PP
Set the activity at cycle of the node\&. \fBParameters:\fP
.RS 4
\fIconst\fP Cycle & cycle The cycle the activty is on 
.br
\fIdouble\fP The current activity value to be set
.RE
.PP
\fBReturns:\fP
.RS 4
double The activity set 
.RE
.PP

.PP
Definition at line 287 of file Node\&.cpp\&.
.PP
References addActivity()\&.
.SS "void \fBcryomesh::components::Node::setPosition\fP (const spacial::Point &new_position)"
.PP
Set the spacial position of the node, remembering to update connections lengths\&. \fBParameters:\fP
.RS 4
\fIspacial::Point\fP The position to place this node at 
.RE
.PP

.PP
Definition at line 309 of file Node\&.cpp\&.
.PP
References position, and updatePosition()\&.
.SS "void \fBcryomesh::components::Node::update\fP ()\fC [virtual]\fP"
.PP
Definition at line 49 of file Node\&.cpp\&.
.PP
References checkFire(), cryomesh::components::ImpulseCollection::clearActiveImpulses(), cryomesh::dataobjects::DataObjectController< unsigned long int, double >::dataObject, getActivities(), getMutableImpulses(), cryomesh::dataobjects::DataObject< U, T >::insert(), cryomesh::dataobjects::DataObject< U, T >::isLoggingEnabled(), lastActivationState, and updateImpulses()\&.
.SS "double \fBcryomesh::components::Node::updateActivity\fP ()"
.PP
Update and get the current activity of the node\&. \fBReturns:\fP
.RS 4
double The current activity 
.RE
.PP

.PP
Definition at line 275 of file Node\&.cpp\&.
.PP
References getActivity(), getImpulses(), and setActivity()\&.
.PP
Referenced by checkActivationState()\&.
.SS "double \fBcryomesh::components::Node::updateActivity\fP (const \fBcommon::Cycle\fP &cycle)"
.PP
Update and get the activity of the node on specific cycle\&. \fBReturns:\fP
.RS 4
double The current activity 
.RE
.PP

.PP
Definition at line 279 of file Node\&.cpp\&.
.PP
References getActivity(), getImpulses(), and setActivity()\&.
.SS "void \fBcryomesh::components::Node::updateImpulses\fP ()\fC [protected, virtual]\fP"
.PP
Update the collection of impulses by one cycle\&. 
.PP
Definition at line 135 of file Node\&.cpp\&.
.PP
References cryomesh::components::ImpulseCollection::clearImpulses(), and impulses\&.
.PP
Referenced by update()\&.
.SS "void \fBcryomesh::components::Node::updatePosition\fP ()\fC [protected, virtual]\fP"
.PP
Recalculate state of node and connections based on current position\&. 
.PP
Definition at line 515 of file Node\&.cpp\&.
.PP
References connector\&.
.PP
Referenced by setPosition()\&.
.SH "Friends And Related Function Documentation"
.PP 
.SS "std::ostream& operator<< (std::ostream &os, const \fBNode\fP &obj)\fC [friend]\fP"
.PP
To stream operator\&. \fBParameters:\fP
.RS 4
\fIstd::ostream\fP & os The output stream 
.br
\fIconst\fP \fBNode\fP & obj The object to stream
.RE
.PP
\fBReturns:\fP
.RS 4
std::ostream & The output stream 
.RE
.PP

.PP
Definition at line 548 of file Node\&.cpp\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBdataobjects::DataObject\fP<\fBcommon::Cycle\fP, double> \fBcryomesh::components::Node::activities\fP\fC [private]\fP"
.PP
Definition at line 461 of file Node\&.h\&.
.PP
Referenced by addActivity(), getActivities(), and Node()\&.
.SS "double \fBcryomesh::components::Node::activityThreshold\fP\fC [private]\fP"
.PP
Definition at line 433 of file Node\&.h\&.
.PP
Referenced by getActivityThreshold(), and randomise()\&.
.SS "boost::shared_ptr<\fBcommon::Connector\fP<\fBNode\fP, \fBConnection\fP> > \fBcryomesh::components::Node::connector\fP\fC [private]\fP"
.PP
Definition at line 440 of file Node\&.h\&.
.PP
Referenced by getConnector(), getMutableConnector(), Node(), and updatePosition()\&.
.SS "\fBdataobjects::DataObject\fP<unsigned long int , double > \fBcryomesh::dataobjects::DataObjectController\fP< unsigned long int , double  >::\fBdataObject\fP\fC [protected, inherited]\fP"
.PP
Definition at line 85 of file DataObjectController\&.h\&.
.PP
Referenced by cryomesh::components::ImpulseCollection::refreshDataObject(), and update()\&.
.SS "boost::shared_ptr<\fBImpulse\fP> \fBcryomesh::components::Node::emittedImpulse\fP\fC [private]\fP"
.PP
Definition at line 454 of file Node\&.h\&.
.PP
Referenced by getEmittedImpulse(), getMutableEmittedImpulse(), Node(), and randomise()\&.
.SS "\fBImpulseCollection\fP \fBcryomesh::components::Node::impulses\fP\fC [private]\fP"
.PP
Definition at line 447 of file Node\&.h\&.
.PP
Referenced by addImpulses(), enterRecovery(), getImpulses(), getMutableImpulses(), and updateImpulses()\&.
.SS "\fBActivationState\fP \fBcryomesh::components::Node::lastActivationState\fP\fC [private]\fP"
.PP
Definition at line 475 of file Node\&.h\&.
.PP
Referenced by getLastActivationState(), and update()\&.
.SS "const int \fBcryomesh::components::Node::MAX_ACTIVITIES_LENGTH\fP = 10\fC [static]\fP"
.PP
Definition at line 341 of file Node\&.h\&.
.PP
Referenced by Node()\&.
.SS "const double \fBcryomesh::components::Node::MAX_ACTIVITY_THRESHOLD\fP = 3 * \fBImpulse::MAX_ACTIVITY\fP\fC [static]\fP"
.PP
Definition at line 348 of file Node\&.h\&.
.PP
Referenced by randomise()\&.
.SS "const spacial::Point \fBcryomesh::components::Node::MAX_BOUNDING_BOX_POINT\fP = spacial::Point(100, 100, 100)\fC [static]\fP"
.PP
Definition at line 362 of file Node\&.h\&.
.SS "const double \fBcryomesh::components::Node::MIN_ACTIVITY_THRESHOLD\fP = 1 * \fBImpulse::MAX_ACTIVITY\fP\fC [static]\fP"
.PP
Definition at line 355 of file Node\&.h\&.
.PP
Referenced by randomise()\&.
.SS "spacial::Point \fBcryomesh::components::Node::position\fP\fC [private]\fP"
.PP
Definition at line 468 of file Node\&.h\&.
.PP
Referenced by getPosition(), and setPosition()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for cryomesh from the source code\&.
